<!DOCTYPE html>
<html>
<head>
  <title>Dungeons and Daisies Runner</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      background-color: #000;
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ */
      user-select: none; /* Standard syntax */
    }
    canvas {
      display: block;
      border: 2px solid #fff;
    }
    /* Styles for on-screen controls */
    .control-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: rgba(128, 128, 128, 0.5);
        border: 2px solid white;
        color: white;
        font-size: 24px;
        margin: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .control-btn:active {
        background-color: rgba(255, 255, 255, 0.5);
    }
  </style>
</head>
<body>
<!-- On-screen control elements -->
<div id="controls-container" style="position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: space-between; z-index: 10; pointer-events: none;">
    <div id="move-controls" style="display: none; pointer-events: auto;">
        <button id="left-btn" class="control-btn">â—€</button>
        <button id="right-btn" class="control-btn">â–¶</button>
    </div>
    <div id="attack-control" style="display: none; pointer-events: auto;">
        <button id="fire-btn" class="control-btn">ðŸ”¥</button>
    </div>
</div>

<script>
let player;
let obstacles = [];
let daisies = [];
let score = 0;
let gameOver = false;
let groundY;
let baseSpeed = -6;
let boss;
let sword;
let greenFlames = [];
let redFlames = [];
let playerRunSprites = [];
let playerRunSwordSprites = [];
let magicalSwordSprite;
let greenFlameSprite;
let currentFrame = 0;
let frameDelay = 4;
let boneSprite;
let daisySprite;
let backgroundImg;
let midgroundImg;
let titleImg;
let song;
let jumpSound, daisySound;
let backgroundX = 0;
let midgroundX = 0;
let scaleFactor = 1;
let originalWidth = 800;
let originalHeight = 400;
let restartButton = null;
let isHoveringRestart = false;
let gameState = "title";
let titleStartTime;
let swordCollected = false;
let keys = {};

let leftBtn, rightBtn, fireBtn, moveControls, attackControl;

let nextObstacleFrame = 0;
let nextDaisyFrame = 0;

let torchLayer;
// NEW: Variable to control the torch's radius for the expansion effect
let torchRadius;
const INITIAL_TORCH_RADIUS = 250;

function preload() {
  try {
    playerRunSprites[0] = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/player_run1.png');
    playerRunSprites[1] = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/player_run2.png');
    playerRunSwordSprites[0] = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/run_sword1.png');
    playerRunSwordSprites[1] = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/run_sword2.png');
    magicalSwordSprite = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/powerswordgif.png');
    greenFlameSprite = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/greenflame.png');
    boneSprite = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/skull.PNG');
    daisySprite = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/daisy.PNG');
    backgroundImg = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/background.png');
    midgroundImg = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/midground_chains.png');
    titleImg = loadImage('https://pushybrand.github.io/dungeons-and-daisies-sprites/Dungeons_Daisies_title.png');
    song = loadSound('https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/Deadhedz%20game%20tune.wav');
    jumpSound = loadSound('https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/ES_Retro%2C%208%20Bit%2C%20Jump%2001%20-%20Epidemic%20Sound.mp3');
    daisySound = loadSound('https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/ES_Notification%2C%20Video%20Game%2C%20Collect%20Item%2C%20Select%2001%20-%20Epidemic%20Sound.mp3');
  } catch (e) {
    console.error('Preload error:', e);
  }
}

function setup() {
  let canvasWidth = min(windowWidth, windowHeight * 2);
  let canvasHeight = canvasWidth / 2;
  scaleFactor = canvasWidth / originalWidth;
  let p5canvas = createCanvas(canvasWidth, canvasHeight);
  p5canvas.parent(document.body);

  groundY = height - 50 * scaleFactor;
  player = new Player();
  textFont('VT323');
  titleStartTime = millis();

  setupControls();
  
  torchLayer = createGraphics(width, height);
  // NEW: Initialize torch radius
  torchRadius = INITIAL_TORCH_RADIUS * scaleFactor;
  
  setNextSpawns();
}

function setNextSpawns() {
    nextObstacleFrame = frameCount + random(60, 120);
    nextDaisyFrame = frameCount + random(90, 180);
}

function setupControls() {
    moveControls = document.getElementById('move-controls');
    attackControl = document.getElementById('attack-control');
    leftBtn = document.getElementById('left-btn');
    rightBtn = document.getElementById('right-btn');
    fireBtn = document.getElementById('fire-btn');

    leftBtn.addEventListener('mousedown', () => keys['ArrowLeft'] = true);
    leftBtn.addEventListener('mouseup', () => keys['ArrowLeft'] = false);
    leftBtn.addEventListener('mouseleave', () => keys['ArrowLeft'] = false);
    leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowLeft'] = true; });
    leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowLeft'] = false; });

    rightBtn.addEventListener('mousedown', () => keys['ArrowRight'] = true);
    rightBtn.addEventListener('mouseup', () => keys['ArrowRight'] = false);
    rightBtn.addEventListener('mouseleave', () => keys['ArrowRight'] = false);
    rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowRight'] = true; });
    rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowRight'] = false; });

    fireBtn.addEventListener('mousedown', () => { if (player) player.attack(); });
    fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (player) player.attack(); });
}


function windowResized() {
  let canvasWidth = min(windowWidth, windowHeight * 2);
  let canvasHeight = canvasWidth / 2;
  scaleFactor = canvasWidth / originalWidth;
  resizeCanvas(canvasWidth, canvasHeight);
  groundY = height - 50 * scaleFactor;
  if (player) player.adjustPosition();
  torchLayer = createGraphics(width, height);
  // NEW: Adjust torch radius on resize if not currently expanding
  if (score < 200) {
      torchRadius = INITIAL_TORCH_RADIUS * scaleFactor;
  }
}

class Player {
  constructor() {
    this.w = 96 * scaleFactor;
    this.h = 96 * scaleFactor;
    this.hitboxW = 64 * scaleFactor;
    this.hitboxH = 64 * scaleFactor;
    this.hitboxOffsetX = (this.w - this.hitboxW) / 2;
    this.hitboxOffsetY = (this.h - this.hitboxH) / 2;
    this.x = 100 * scaleFactor;
    this.y = groundY - this.h + 20 * scaleFactor;
    this.vy = 0;
    this.gravity = 0.8 * scaleFactor;
    this.jumpForce = -15 * scaleFactor;
    this.isJumping = false;
    this.speed = 5 * scaleFactor;
    this.health = 100;
    this.flashTimer = 0;
  }

  jump() {
    if (jumpSound && jumpSound.isLoaded()) {
        jumpSound.play();
    }
    this.vy = this.jumpForce;
    this.isJumping = true;
  }

  attack() {
    greenFlames.push(new GreenFlame(this.x + this.w, this.y + this.h / 2));
  }

  update() {
    this.vy += this.gravity;
    this.y += this.vy;
    if (this.y > groundY - this.h + 20 * scaleFactor) {
      this.y = groundY - this.h + 20 * scaleFactor;
      this.vy = 0;
      this.isJumping = false;
    }
    if (gameState === "boss" || (score >= 200 && !swordCollected)) {
      if (keys['ArrowLeft'] || keys['a']) this.x = max(0, this.x - this.speed);
      if (keys['ArrowRight'] || keys['d']) this.x = min(width - this.w, this.x + this.speed);
    }
  }

  show() {
    if (millis() - this.flashTimer < 200 && frameCount % 4 < 2) return;
    let sprites = swordCollected ? playerRunSwordSprites : playerRunSprites;
    if (sprites[currentFrame]) {
      image(sprites[currentFrame], this.x, this.y, this.w, this.h);
    } else {
      fill(0, 255, 0);
      rect(this.x, this.y, this.w, this.h);
    }
  }

  adjustPosition() {
    this.w = 96 * scaleFactor;
    this.h = 96 * scaleFactor;
    this.hitboxW = 64 * scaleFactor;
    this.hitboxH = 64 * scaleFactor;
    this.hitboxOffsetX = (this.w - this.hitboxW) / 2;
    this.hitboxOffsetY = (this.h - this.hitboxH) / 2;
    this.x = 100 * scaleFactor;
    this.y = groundY - this.h + 20 * scaleFactor;
  }
}

class Sword {
  constructor() {
    this.w = 100 * scaleFactor;
    this.h = 200 * scaleFactor;
    this.x = width / 2 - this.w / 2;
    this.baseY = 100 * scaleFactor;
    this.y = this.baseY;
  }

  show() {
    let hoverY = this.baseY + sin(frameCount * 0.1) * 10 * scaleFactor;
    if (magicalSwordSprite) {
      image(magicalSwordSprite, this.x, hoverY, this.w, this.h);
    } else {
      fill(0, 255, 255);
      rect(this.x, hoverY, this.w, this.h);
    }
  }

  hits(player) {
    return player.x + player.w > this.x &&
           player.x < this.x + this.w &&
           player.y + player.h > this.y &&
           player.y < this.y + this.h;
  }
}

class GreenFlame {
  constructor(x, y) {
    this.w = 40 * scaleFactor;
    this.h = 40 * scaleFactor;
    this.x = x;
    this.y = y;
    this.speed = 8 * scaleFactor;
  }

  update() {
    this.x += this.speed;
  }

  show() {
    if (greenFlameSprite) {
      image(greenFlameSprite, this.x, this.y, this.w, this.h);
    } else {
      fill(0, 255, 0);
      ellipse(this.x + this.w / 2, this.y + this.h / 2, this.w, this.h);
    }
  }

  hits(boss) {
    return this.x + this.w > boss.x &&
           this.x < boss.x + boss.w &&
           this.y + this.h > boss.y &&
           this.y < boss.y + boss.h;
  }

  offscreen() {
    return this.x > width;
  }
}

class RedFlame {
  constructor(x, y) {
    this.w = 20 * scaleFactor;
    this.h = 20 * scaleFactor;
    this.x = x;
    this.y = y;
    this.speed = -8 * scaleFactor;
  }

  update() {
    this.x += this.speed;
  }

  show() {
    fill(255, 0, 0);
    ellipse(this.x + this.w / 2, this.y + this.h / 2, this.w, this.h);
  }

  hits(player) {
    let playerHitboxX = player.x + player.hitboxOffsetX;
    let playerHitboxY = player.y + player.hitboxOffsetY;
    return playerHitboxX + player.hitboxW > this.x &&
           playerHitboxX < this.x + this.w &&
           playerHitboxY + player.hitboxH > this.y &&
           playerHitboxY < this.y + this.h;
  }

  offscreen() {
    return this.x + this.w < 0;
  }
}

class Boss {
  constructor() {
    this.w = 150 * scaleFactor;
    this.h = 150 * scaleFactor;
    this.x = width - this.w;
    this.y = groundY - this.h;
    this.speed = 2 * scaleFactor;
    this.health = 100;
    this.attackTimer = 0;
    this.flashTimer = 0;
    this.moveTimer = 0;
    this.direction = -1;
  }

  update() {
    this.moveTimer++;
    if (this.moveTimer > 120) {
        this.direction = random([-1, 1, 0]);
        this.moveTimer = 0;
    }

    this.x += this.speed * this.direction;

    if (this.x < width / 2) {
        this.x = width / 2;
        this.direction = 1;
        this.moveTimer = 0;
    }
    if (this.x + this.w > width) {
        this.x = width - this.w;
        this.direction = -1;
        this.moveTimer = 0;
    }
    
    this.attackTimer++;
    if (this.attackTimer >= 60) {
      redFlames.push(new RedFlame(this.x, this.y + this.h / 2));
      this.attackTimer = 0;
    }
  }

  show() {
    if (millis() - this.flashTimer < 200 && frameCount % 4 < 2) return;
    fill(100);
    stroke(255, 0, 0);
    strokeWeight(2 * scaleFactor);
    rect(this.x, this.y, this.w, this.h);
  }

  hits(player) {
    let playerHitboxX = player.x + player.hitboxOffsetX;
    let playerHitboxY = player.y + player.hitboxOffsetY;
    return playerHitboxX + player.hitboxW > this.x &&
           playerHitboxX < this.x + this.w &&
           playerHitboxY + player.hitboxH > this.y &&
           playerHitboxY < this.y + this.h;
  }
}

class Obstacle {
  constructor() {
    this.w = 48 * scaleFactor;
    this.h = 48 * scaleFactor;
    this.hitboxW = 32 * scaleFactor;
    this.hitboxH = 32 * scaleFactor;
    this.hitboxOffsetX = (this.w - this.hitboxW) / 2;
    this.hitboxOffsetY = (this.h - this.hitboxH) / 2;
    this.x = width;
    this.y = groundY - this.h + 20 * scaleFactor;
    this.speed = baseSpeed * scaleFactor;
  }

  update() {
    this.x += this.speed;
  }

  show() {
    if (boneSprite) {
      image(boneSprite, this.x, this.y, this.w, this.h);
    } else {
      fill(150);
      stroke(0);
      strokeWeight(2 * scaleFactor);
      rect(this.x, this.y, this.w, this.h);
    }
  }

  hits(player) {
    let playerHitboxX = player.x + player.hitboxOffsetX;
    let playerHitboxY = player.y + player.hitboxOffsetY;
    let thisHitboxX = this.x + this.hitboxOffsetX;
    let thisHitboxY = this.y + this.hitboxOffsetY;
    return playerHitboxX + player.hitboxW > thisHitboxX &&
           playerHitboxX < thisHitboxX + this.hitboxW &&
           playerHitboxY + player.hitboxH > thisHitboxY &&
           playerHitboxY < thisHitboxY + this.hitboxH;
  }

  offscreen() {
    return this.x + this.w < 0;
  }
}

class Daisy {
  constructor() {
    this.w = 48 * scaleFactor;
    this.h = 48 * scaleFactor;
    this.x = width;
    this.y = random(150 * scaleFactor, groundY - this.h);
    this.speed = baseSpeed * scaleFactor;
  }

  update() {
    this.x += this.speed;
  }

  show() {
    if (daisySprite) {
      image(daisySprite, this.x, this.y, this.w, this.h);
    } else {
      fill(255, 255, 0);
      stroke(0);
      strokeWeight(2 * scaleFactor);
      ellipse(this.x + this.w / 2, this.y + this.h / 2, this.w, this.h);
    }
  }

  hits(player) {
    return player.x + player.w > this.x &&
           player.x < this.x + this.w &&
           player.y + player.h > this.y &&
           player.y < this.y + this.h;
  }

  offscreen() {
    return this.x + this.w < 0;
  }
}

function resetGame() {
  player = new Player();
  obstacles = [];
  daisies = [];
  score = 0;
  gameOver = false;
  currentFrame = 0;
  baseSpeed = -6;
  backgroundX = 0;
  midgroundX = 0;
  swordCollected = false;
  sword = null;
  boss = null;
  greenFlames = [];
  redFlames = [];
  gameState = "playing";
  if (restartButton) {
    restartButton.remove();
    restartButton = null;
  }
  // NEW: Reset torch radius on game reset
  torchRadius = INITIAL_TORCH_RADIUS * scaleFactor;
  setNextSpawns();
  loop(); 
}

function keyPressed() {
  if (!player) return;

  if (key === ' ') {
    if (gameOver) {
      resetGame();
    } else if (gameState === "title") {
      gameState = "playing";
      if (song && song.isLoaded() && !song.isPlaying()) {
        song.loop();
      }
    } else if ((gameState === "playing" || gameState === "boss") && !player.isJumping) {
      player.jump();
    }
    return false; 
  }

  if (keyCode === ENTER && swordCollected && gameState === "boss") {
    player.attack();
  }

  if (gameState === "boss" || (score >= 200 && !swordCollected)) {
    keys[key.toLowerCase()] = true;
    keys[key] = true;
  }
}

function keyReleased() {
  if (!player) return;
  
  if (gameState === "boss" || (score >= 200 && !swordCollected)) {
    keys[key.toLowerCase()] = false;
    keys[key] = false;
  }
}

function touchStarted(event) {
  if (!player) return;

  if (event.target.classList.contains('control-btn')) {
      return false;
  }

  if (gameState === "title") {
    gameState = "playing";
    if (song && song.isLoaded() && !song.isPlaying()) {
        song.loop();
    }
  } else if ((gameState === "playing" || gameState === "boss") && !player.isJumping) {
    player.jump();
  } else if (gameOver) {
    resetGame();
  }
  return false;
}

function manageControls() {
    const showMovement = (score >= 200 && !swordCollected) || gameState === "boss";
    const showAttack = gameState === "boss" && swordCollected;

    if (showMovement) {
        moveControls.style.display = 'flex';
    } else {
        moveControls.style.display = 'none';
    }

    if (showAttack) {
        attackControl.style.display = 'block';
    } else {
        attackControl.style.display = 'none';
    }
}

function drawPixelatedTorchEffect() {
    // UPDATED: Use fill() and rect() for a reliable semi-transparent overlay
    torchLayer.clear();
    torchLayer.fill(0, 220); // Black with high opacity for the dark areas
    torchLayer.noStroke();
    torchLayer.rect(0, 0, width, height);

    torchLayer.erase();

    let playerCenterX = player.x + player.w / 2;
    let playerCenterY = player.y + player.h / 2;
    // UPDATED: Use the dynamic torchRadius variable
    let lightRadius = torchRadius;
    let pixelSize = 16 * scaleFactor; 

    torchLayer.ellipse(playerCenterX, playerCenterY, player.w * 1.5, player.w * 1.5);

    for (let x = playerCenterX - lightRadius; x < playerCenterX + lightRadius; x += pixelSize) {
        for (let y = playerCenterY - lightRadius; y < playerCenterY + lightRadius; y += pixelSize) {
            let d = dist(x, y, playerCenterX, playerCenterY);
            if (d < lightRadius) {
                torchLayer.rect(x, y, pixelSize, pixelSize);
            }
        }
    }
    
    torchLayer.noErase();
    image(torchLayer, 0, 0);
}


function draw() {
  manageControls(); 

  if (gameState === "title") {
    background(0);
    if (backgroundImg) image(backgroundImg, backgroundX, 0, width, height);
    if (midgroundImg) image(midgroundImg, midgroundX, 0, width, height);
    if (titleImg) image(titleImg, 0, 0, width, height);
    else {
      fill(255);
      textSize(32 * scaleFactor);
      textAlign(CENTER, CENTER);
      text("Dungeons and Daisies Runner\nPress to Start", width / 2, height / 2);
    }
    return;
  }

  background(0);
  if (backgroundImg) {
    image(backgroundImg, backgroundX, 0, width, height);
    image(backgroundImg, backgroundX + width, 0, width, height);
  }
  if (midgroundImg) {
    image(midgroundImg, midgroundX, 0, width, height);
    image(midgroundImg, midgroundX + width, 0, width, height);
  }

  if (gameState === "playing" && score < 200) { 
    backgroundX += baseSpeed * scaleFactor;
    midgroundX += baseSpeed * scaleFactor;
    if (backgroundX <= -width) backgroundX += width;
    if (midgroundX <= -width) midgroundX += width;
  }

  if (gameState === "playing" || (score >= 200 && !swordCollected)) {
    if (frameCount % frameDelay === 0) {
      currentFrame = (currentFrame + 1) % (swordCollected ? playerRunSwordSprites.length : playerRunSprites.length);
    }

    if (frameCount % 300 === 0 && score < 200) {
      baseSpeed -= 0.5;
    }
    
    if (frameCount > nextObstacleFrame && score < 200) {
        obstacles.push(new Obstacle());
        nextObstacleFrame = frameCount + random(50, 100) / (abs(baseSpeed)/6);
    }
    if (frameCount > nextDaisyFrame && score < 200) {
        daisies.push(new Daisy());
        nextDaisyFrame = frameCount + random(80, 150);
    }

    player.update();
    player.show();

    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].update();
      obstacles[i].show();
      if (obstacles[i].hits(player)) {
        gameOver = true;
      } else if (obstacles[i].offscreen()) {
        obstacles.splice(i, 1);
      }
    }

    for (let i = daisies.length - 1; i >= 0; i--) {
      daisies[i].update();
      daisies[i].show();
      if (daisies[i].hits(player)) {
        score += 10;
        if (daisySound && daisySound.isLoaded()) daisySound.play();
        daisies.splice(i, 1);
      } else if (daisies[i].offscreen()) {
        daisies.splice(i, 1);
      }
    }

    // UPDATED: Logic for torch expansion and sword spawning
    if (score >= 200 && !sword && !swordCollected) {
        if (torchRadius < width) { // Expand the torch until it fills the screen
            torchRadius += 15 * scaleFactor;
        } else { // Once expanded, create the sword
            sword = new Sword();
        }
    }

    if (sword) {
      sword.show();
      if (sword.hits(player)) {
        swordCollected = true;
        sword = null;
        boss = new Boss();
        gameState = "boss";
      }
    }
  }

  if (gameState === "boss") {
    if (frameCount % frameDelay === 0 && (keys['ArrowLeft'] || keys['a'] || keys['ArrowRight'] || keys['d']) && swordCollected) {
      currentFrame = (currentFrame + 1) % playerRunSwordSprites.length;
    }

    player.update();
    player.show();
    boss.update();
    boss.show();

    for (let i = greenFlames.length - 1; i >= 0; i--) {
      greenFlames[i].update();
      greenFlames[i].show();
      if (greenFlames[i].hits(boss)) {
        boss.health -= 5;
        boss.flashTimer = millis();
        greenFlames.splice(i, 1);
      } else if (greenFlames[i].offscreen()) {
        greenFlames.splice(i, 1);
      }
    }

    for (let i = redFlames.length - 1; i >= 0; i--) {
      redFlames[i].update();
      redFlames[i].show();
      if (redFlames[i].hits(player)) {
        player.health -= 10;
        player.flashTimer = millis();
        redFlames.splice(i, 1);
        if (player.health <= 0) gameOver = true;
      } else if (redFlames[i].offscreen()) {
        redFlames.splice(i, 1);
      }
    }

    if (boss.hits(player) && millis() - player.flashTimer > 1000) {
      player.health -= 20;
      player.flashTimer = millis();
      if (player.health <= 0) gameOver = true;
    }

    if (boss.health <= 0) {
      score += 50;
      gameOver = true;
    }
  }
  
  // UPDATED: Draw the torch effect only before the sword is created
  if (gameState !== 'title' && !sword && !swordCollected) {
      drawPixelatedTorchEffect();
  }

  if (gameState === 'boss') {
    fill(255);
    textSize(24 * scaleFactor);
    textAlign(LEFT);
    text("Player HP: " + player.health, 10 * scaleFactor, 30 * scaleFactor);
    fill(255, 0, 0);
    rect(10 * scaleFactor, 40 * scaleFactor, player.health * 2 * scaleFactor, 10 * scaleFactor);
    fill(255);
    textAlign(CENTER);
    text("Boss HP: " + boss.health, width / 2, 30 * scaleFactor);
    fill(255, 0, 0);
    rect(width / 2 - 100 * scaleFactor, 40 * scaleFactor, boss.health * 2 * scaleFactor, 10 * scaleFactor);
  } else if (gameState === 'playing' || (score >= 200 && !swordCollected)) {
      fill(255);
      textSize(24 * scaleFactor);
      textAlign(LEFT);
      text("Score: " + score, 10 * scaleFactor, 30 * scaleFactor);
  }


  if (gameOver) {
    fill(0, 150);
    rect(0, 0, width, height);
    fill(255);
    textSize(48 * scaleFactor);
    textAlign(CENTER, CENTER);
    let message = boss && boss.health <= 0 ? "Boss Defeated!" : "Game Over";
    text(message, width / 2, height / 2 - 20 * scaleFactor);
    textSize(24 * scaleFactor);
    text("Score: " + score + "\nPress Space to Restart", width / 2, height / 2 + 20 * scaleFactor);
    
    if (!restartButton) {
      restartButton = createButton('Restart');
      restartButton.position(width / 2 - 40 * scaleFactor, height / 2 + 50 * scaleFactor);
      restartButton.style('font-family', 'VT323');
      restartButton.style('font-size', (20 * scaleFactor) + 'px');
      restartButton.mousePressed(resetGame);
      restartButton.mouseOver(() => isHoveringRestart = true);
      restartButton.mouseOut(() => isHoveringRestart = false);
    }
    if (isHoveringRestart) {
      restartButton.style('background-color', '#555');
    } else {
      restartButton.style('background-color', '#333');
    }
    noLoop(); 
  }
}
</script>
</body>
</html>


















