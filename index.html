<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dungeons & Daisies Runner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #1a1a1a;
        margin: 0;
        overflow: hidden;
      }
      canvas {
        border: 2px solid #fff;
      }
    </style>
  </head>
  <body>
    <script>
      // Game Variables
      let player;
      let obstacles = [];
      let daisies = [];
      let score = 0;
      let gameOver = false;
      let gameState = "title"; // "title", "playing", "boss"

      // Image and Asset Variables
      let playerRun, playerJump, obstacleImg, daisyImg, swordImg, bossImg, flameImg;
      let backgroundImg, titleImg;
      let backgroundX = 0;

      // Game Mechanics
      let groundY;
      let baseSpeed = 2;
      let scaleFactor = 2;
      let restartButton;
      let sword;
      let boss;
      let flames = [];

      // Preload all assets
      function preload() {
        // --- VERIFIED WORKING URLs ---
        backgroundImg = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/background2.png"
        );
        titleImg = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/dnd-title.png"
        );
        playerRun = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/run-sprites.png"
        );
        playerJump = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/jump-sprites.png"
        );
        obstacleImg = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/skull.png"
        );
        daisyImg = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/daisy.png"
        );
        swordImg = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/sword.png"
        );
        bossImg = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/dragon-flame.png"
        );
        flameImg = loadImage(
          "https://raw.githubusercontent.com/pushybrand/dungeons-and-daisies-sprites/main/flame.png"
        );
      }

      function setup() {
        createCanvas(480 * scaleFactor, 270 * scaleFactor);
        groundY = height - 40 * scaleFactor;
        resetGame();
      }

      function resetGame() {
        player = new Player();
        obstacles = [];
        daisies = [];
        flames = [];
        score = 0;
        gameOver = false;
        gameState = "playing";
        sword = null;
        boss = null;
        backgroundX = 0;
        loop(); // Ensure the loop is running
      }

      function draw() {
        // Title Screen
        if (gameState === "title") {
          background(0);
           if (backgroundImg) {
            image(backgroundImg, backgroundX, 0, width, height);
            image(backgroundImg, backgroundX + width, 0, width, height);
          }
          if (titleImg) {
            image(titleImg, 0, 0, width, height);
          } else {
            fill(255);
            textSize(32 * scaleFactor);
            textAlign(CENTER, CENTER);
            text("Dungeons and Daisies Runner\nPress to Start", width / 2, height / 2);
          }
          return;
        }
        
        if (gameOver) return; // Stop drawing if game is over

        // --- BACKGROUND ---
        // Draw the scrolling background
        if (gameState === "playing" || (gameState === "boss" && boss && boss.x > width * 0.75)) {
            backgroundX -= baseSpeed * scaleFactor;
            if (backgroundX <= -width) {
                backgroundX = 0;
            }
        }
        image(backgroundImg, backgroundX, 0, width, height);
        image(backgroundImg, backgroundX + width, 0, width, height);
        
        // --- GAME LOGIC ---
        if (gameState === "playing") {
          handlePlayingState();
        } else if (gameState === "boss") {
          handleBossState();
        }
        
        // Draw Score
        fill(255);
        textSize(20 * scaleFactor);
        textAlign(RIGHT, TOP);
        text("Score: " + score, width - 10, 10);
      }

      function handlePlayingState() {
        player.update();
        player.show();

        // Handle Obstacles
        if (frameCount % 90 === 0) {
          obstacles.push(new Obstacle());
        }
        for (let i = obstacles.length - 1; i >= 0; i--) {
          obstacles[i].update();
          obstacles[i].show();
          if (player.hits(obstacles[i])) {
            triggerGameOver();
          }
          if (obstacles[i].isOffscreen()) {
            obstacles.splice(i, 1);
          }
        }

        // Handle Daisies
        if (frameCount % 60 === 0) {
          daisies.push(new Daisy());
        }
        for (let i = daisies.length - 1; i >= 0; i--) {
          daisies[i].update();
          daisies[i].show();
          if (player.collects(daisies[i])) {
            score += 10;
            daisies.splice(i, 1);
          } else if (daisies[i].isOffscreen()) {
            daisies.splice(i, 1);
          }
        }

        // Check for Boss Trigger
        if (score >= 200 && !sword) {
          sword = new Sword();
        }
        if (sword) {
          sword.update();
          sword.show();
          if (player.collects(sword)) {
            gameState = "boss";
            boss = new Boss();
            obstacles = []; // Clear remaining obstacles
            daisies = []; // Clear remaining daisies
            sword = null;
          }
        }
      }

      function handleBossState() {
        player.update();
        player.show();

        boss.update();
        boss.show();

        if (boss.hits(player) && !player.isInvincible) {
           player.takeDamage(25);
        }
        
        // Handle flames
        for (let i = flames.length - 1; i >= 0; i--) {
            flames[i].update();
            flames[i].show();
            if(boss.isHitBy(flames[i])) {
                boss.takeDamage(10);
                flames.splice(i,1);
            }
        }
        
        if (player.health <= 0) {
            triggerGameOver();
        }
        if (boss.health <= 0) {
           triggerWin();
        }
      }

      function triggerGameOver() {
        gameOver = true;
        noLoop(); // Stop the draw loop
        
        // Display Game Over screen
        fill(0, 150);
        rect(0, 0, width, height);
        fill(255);
        textSize(48 * scaleFactor);
        textAlign(CENTER, CENTER);
        text("GAME OVER", width / 2, height / 2 - 20 * scaleFactor);

        restartButton = createButton('Restart');
        restartButton.position(width / 2 - (restartButton.width / 2), height / 2 + 50 * scaleFactor);
        restartButton.style('font-size', (20 * scaleFactor) + 'px');
        restartButton.style('padding', '10px 20px');
        restartButton.mousePressed(() => {
          restartButton.remove();
          gameState = "title";
          gameOver = false;
          loop(); // Restart the draw loop to show title
        });
      }

       function triggerWin() {
        gameOver = true;
        noLoop();
        fill(0, 150);
        rect(0, 0, width, height);
        fill(255, 215, 0); // Gold color for win
        textSize(48 * scaleFactor);
        textAlign(CENTER, CENTER);
        text("YOU WIN!", width / 2, height / 2 - 40 * scaleFactor);
        textSize(24 * scaleFactor);
        text("You have proven your worth, Forerunner.", width / 2, height / 2 + 20 * scaleFactor);

        // Here you would add the button/link to claim WL
        let claimButton = createButton('Claim WL Spot');
        claimButton.position(width/2 - (claimButton.width/2), height / 2 + 80 * scaleFactor);
        claimButton.style('font-size', (20 * scaleFactor) + 'px');
        claimButton.style('padding', '10px 20px');
        claimButton.mousePressed(() => {
            // This is where you would link to your Typeform/Google Form
            window.open('https://your-whitelist-form-link.com', '_blank');
        });
      }

      function keyPressed() {
        if (gameState === "title" && (key === ' ' || keyCode === 32)) {
          resetGame();
        }
        
        if (key === ' ' || keyCode === UP_ARROW) {
          if (gameState === "playing" || gameState === "boss") {
            player.jump();
          }
        }
        
        if (gameState === "boss" && (key === 'x' || key === 'X')) {
             flames.push(new Flame(player.x + player.w, player.y + player.h/2));
        }
      }
      
      function mousePressed() {
         if (gameState === "title") {
          resetGame();
        }
      }

      // --- CLASSES ---

      class Player {
        constructor() {
          this.w = 50 * scaleFactor;
          this.h = 70 * scaleFactor;
          this.x = this.w;
          this.y = groundY - this.h;
          this.vy = 0;
          this.gravity = 0.8 * scaleFactor;
          this.sprite = playerRun;
          this.frame = 0;
          this.frameCount = 8;
          this.frameWidth = 96;
          this.frameHeight = 96;
          
          this.health = 100;
          this.isInvincible = false;
          this.invincibilityTimer = 0;
        }

        jump() {
          if (this.y === groundY - this.h) {
            this.vy = -18 * scaleFactor;
            this.sprite = playerJump;
            this.frameCount = 6;
          }
        }

        update() {
          this.vy += this.gravity;
          this.y += this.vy;

          if (this.y >= groundY - this.h) {
            this.y = groundY - this.h;
            this.vy = 0;
            if (this.sprite === playerJump) {
              this.sprite = playerRun;
              this.frameCount = 8;
            }
          }
          
          // Invincibility flicker
          if (this.isInvincible) {
              this.invincibilityTimer--;
              if (this.invincibilityTimer <= 0) {
                  this.isInvincible = false;
              }
          }
        }

        show() {
          this.frame = (this.frame + 0.25) % this.frameCount;
          
          if(this.isInvincible && floor(this.invincibilityTimer / 6) % 2 === 0) {
              // Don't draw to create flicker effect
          } else {
             image(
                this.sprite,
                this.x,
                this.y,
                this.w,
                this.h,
                floor(this.frame) * this.frameWidth,
                0,
                this.frameWidth,
                this.frameHeight
              );
          }
          
          // Health Bar
           if (gameState === "boss") {
               fill(255,0,0);
               rect(this.x, this.y - 20, this.w, 10);
               fill(0,255,0);
               rect(this.x, this.y - 20, this.w * (this.health/100), 10);
           }
        }

        hits(obstacle) {
          return collideRectRect(this.x, this.y, this.w, this.h, obstacle.x, obstacle.y, obstacle.w, obstacle.h);
        }

        collects(collectible) {
          return collideRectRect(this.x, this.y, this.w, this.h, collectible.x, collectible.y, collectible.w, collectible.h);
        }
        
        takeDamage(amount) {
            this.health -= amount;
            this.isInvincible = true;
            this.invincibilityTimer = 90; // 1.5 seconds at 60fps
        }
      }

      class Obstacle {
        constructor() {
          this.w = 40 * scaleFactor;
          this.h = 40 * scaleFactor;
          this.x = width;
          this.y = groundY - this.h;
        }

        update() {
          this.x -= baseSpeed * scaleFactor;
        }

        show() {
          image(obstacleImg, this.x, this.y, this.w, this.h);
        }

        isOffscreen() {
          return this.x < -this.w;
        }
      }
      
      class Daisy {
        constructor() {
            this.w = 30 * scaleFactor;
            this.h = 30 * scaleFactor;
            this.x = width;
            this.y = groundY - this.h - random(30, 100) * scaleFactor;
        }
        update() {
            this.x -= baseSpeed * scaleFactor;
        }
        show() {
            image(daisyImg, this.x, this.y, this.w, this.h);
        }
        isOffscreen() {
            return this.x < -this.w;
        }
      }
      
      class Sword {
        constructor() {
            this.w = 60 * scaleFactor;
            this.h = 60 * scaleFactor;
            this.x = width;
            this.y = height / 2;
        }
        update() {
            this.x -= baseSpeed * scaleFactor;
        }
        show() {
            image(swordImg, this.x, this.y, this.w, this.h);
        }
      }
      
      class Boss {
          constructor() {
              this.w = 120 * scaleFactor;
              this.h = 120 * scaleFactor;
              this.x = width;
              this.y = groundY - this.h;
              this.health = 500;
              this.speedX = -1 * scaleFactor;
              this.moveTimer = 0;
          }
          
          update() {
              if (this.x > width - this.w - 20) {
                  this.x += this.speedX;
              } else {
                  // Random movement logic
                  this.moveTimer--;
                  if (this.moveTimer <= 0) {
                      let action = random(['forward', 'backward', 'pause']);
                      if (action === 'forward' && this.x > width * 0.5) {
                          this.speedX = -random(0.5, 1.5) * scaleFactor;
                          this.moveTimer = random(60,






















